// Copyright (c) 2012-2013 The PPCoin developers
// Copyright (c) 2014 The BlackCoin developers
// Copyright (c) 2018 The NIX Core developers
// Distributed under the MIT/X11 software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <boost/assign/list_of.hpp>

#include <pos/kernel.h>
#include <txdb.h>
#include <validation.h>
#include <chainparams.h>
#include <serialize.h>
#include <streams.h>
#include <hash.h>
#include <script/interpreter.h>
#include <script/script.h>
#include <script/ismine.h> // valtype
#include <policy/policy.h>
#include <consensus/validation.h>
#include <coins.h>

/**
 * Stake Modifier (hash modifier of proof-of-stake):
 * The purpose of stake modifier is to prevent a txout (coin) owner from
 * computing future proof-of-stake generated by this txout at the time
 * of transaction confirmation. To meet kernel protocol, the txout
 * must hash with a future stake modifier to generate the proof.
 */
uint256 ComputeStakeModifierV2(const CBlockIndex *pindexPrev, const uint256 &kernel)
{
    if (!pindexPrev)
        return uint256();  // genesis block's modifier is 0

    CDataStream ss(SER_GETHASH, 0);
    ss << kernel << pindexPrev->bnStakeModifier;
    return Hash(ss.begin(), ss.end());
}

/**
 * BlackCoin kernel protocol
 * coinstake must meet hash target according to the protocol:
 * kernel (input 0) must meet the formula
 *     hash(nStakeModifier + txPrev.block.nTime + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime) < bnTarget * nWeight
 * this ensures that the chance of getting a coinstake is proportional to the
 * amount of coins one owns.
 * The reason this hash is chosen is the following:
 *   nStakeModifier: scrambles computation to make it very difficult to precompute
 *                   future proof-of-stake
 *   txPrev.block.nTime: prevent nodes from guessing a good timestamp to
 *                       generate transaction for future advantage,
 *                       obsolete since v3
 *   txPrev.nTime: slightly scrambles computation
 *   txPrev.vout.hash: hash of txPrev, to reduce the chance of nodes
 *                     generating coinstake at the same time
 *   txPrev.vout.n: output number of txPrev, to reduce the chance of nodes
 *                  generating coinstake at the same time
 *   nTime: current timestamp
 *   block/tx hash should not be used here as they can be generated in vast
 *   quantities so as to generate blocks faster, degrading the system back into
 *   a proof-of-work situation.
 */
bool CheckStakeKernelHash(const CBlockIndex *pindexPrev,
    uint32_t nBits, uint32_t nBlockFromTime,
    CAmount prevOutAmount, const COutPoint &prevout, uint32_t nTime,
    uint256 &hashProofOfStake, uint256 &targetProofOfStake,
    bool fPrintProofOfStake)
{
    // CheckStakeKernelHashV2

    if (nTime < nBlockFromTime)  // Transaction timestamp violation
        return error("%s: nTime violation", __func__);

    arith_uint256 bnTarget;
    bool fNegative;
    bool fOverflow;

    bnTarget.SetCompact(nBits, &fNegative, &fOverflow);
    if (fNegative || fOverflow || bnTarget == 0)
        return error("%s: SetCompact failed.", __func__);

    // Weighted target
    int64_t nValueIn = prevOutAmount;
    arith_uint256 bnWeight = arith_uint256(nValueIn);
    bnTarget *= bnWeight;

    targetProofOfStake = ArithToUint256(bnTarget);

    uint256 bnStakeModifier = pindexPrev->bnStakeModifier;



    CDataStream ss(SER_GETHASH, 0);
    ss << bnStakeModifier;
    ss << nBlockFromTime << prevout.hash << prevout.n << nTime;
    hashProofOfStake = Hash(ss.begin(), ss.end());

    /*
    LogPrintf("CheckStakeKernelHash(): \n"
              "nValue=%llf, \n"
              "bnTarget=%s > hashProofOfStake=%s \n"
              "bnStakeModifier =%s\n"
              "prevout hash=%s\n"
              "prevout n=%d\n"
              "block from time =%d\n"
              "current block time =%d\n"
              , nValueIn/COIN, bnTarget.ToString(), hashProofOfStake.ToString(), bnStakeModifier.ToString(), prevout.hash.ToString(), prevout.n, nBlockFromTime, nTime);
    */
    // Now check if proof-of-stake hash meets target protocol
    if (UintToArith256(hashProofOfStake) > bnTarget)
        return false;

    return true;
}

bool IsConfirmedInNPrevBlocks(const uint256 &hashBlock, const CBlockIndex *pindexFrom, int nMaxDepth, int &nActualDepth)
{
    for (const CBlockIndex *pindex = pindexFrom; pindex && pindexFrom->nHeight - pindex->nHeight < nMaxDepth; pindex = pindex->pprev)
    if (hashBlock == pindex->GetBlockHash())
    {
        nActualDepth = pindexFrom->nHeight - pindex->nHeight;
        return true;
    };

    return false;
}


static bool CheckAge(const CBlockIndex *pindexTip, const uint256 &hashKernelBlock, int &nDepth)
{
    // pindexTip is the current tip of the chain
    // hashKernelBlock is the hash of the block containing the kernel transaction

    int nRequiredDepth = pindexTip->nHeight + 1 >= Params().GetConsensus().nStartGhostFeeDistribution ?
                COINBASE_MATURITY_V2 : COINBASE_MATURITY;

    bool fTestNet = (Params().NetworkIDString() == CBaseChainParams::TESTNET);
    if(fTestNet)
        nRequiredDepth = COINBASE_MATURITY_TESTNET;

    if (IsConfirmedInNPrevBlocks(hashKernelBlock, pindexTip, nRequiredDepth, nDepth))
        return false;
    return true;
}

// Check kernel hash target and coinstake signature
bool CheckProofOfStake(const CBlockIndex *pindexPrev, const CTransaction &tx, int64_t nTime, unsigned int nBits, uint256 &hashProofOfStake, uint256 &targetProofOfStake)
{
    // pindexPrev is the current tip, the block the new block will connect on
    // nTime is the time of the new/next block
    CValidationState state;

    if (!tx.IsCoinStake()
        || tx.vin.size() < 1)
        return state.DoS(100, error("%s: malformed-txn %s", __func__, tx.GetHash().ToString()), REJECT_INVALID, "malformed-txn");

    uint256 hashBlock;
    CTransactionRef txPrev;

    // Kernel (input 0) must match the stake hash target per coin age (nBits)
    const CTxIn &txin = tx.vin[0];

    uint32_t nBlockFromTime;
    int nDepth;
    CScript kernelPubKey;
    CAmount amount;

    Coin coin;
    if (!pcoinsTip->GetCoin(txin.prevout, coin) || coin.IsSpent())
    {
        // Must find the prevout in the txdb / blocks

        CBlock blockKernel; // block containing stake kernel, GetTransaction should only fill the header.
        if (!GetTransaction(txin.prevout.hash, txPrev, Params().GetConsensus(), blockKernel, true)
            || txin.prevout.n >= txPrev->vout.size())
            return state.DoS(10, error("%s: prevout-not-in-chain", __func__), REJECT_INVALID, "prevout-not-in-chain");

        const CTxOut outPrev = txPrev->vout[txin.prevout.n];

        int nDepth;
        if (!CheckAge(pindexPrev, hashBlock, nDepth))
            return state.DoS(100, error("%s: Tried to stake at depth %d", __func__, nDepth + 1), REJECT_INVALID, "invalid-stake-depth");

        kernelPubKey = outPrev.scriptPubKey;
        amount = outPrev.nValue;
        nBlockFromTime = blockKernel.nTime;
    } else
    {
        CBlockIndex *pindex = chainActive[coin.nHeight];
        if (!pindex)
            return state.DoS(100, error("%s: invalid-prevout", __func__), REJECT_INVALID, "invalid-prevout");

        nDepth = pindexPrev->nHeight - coin.nHeight;

        int nRequiredDepth = pindexPrev->nHeight + 1 >= Params().GetConsensus().nStartGhostFeeDistribution ?
                    COINBASE_MATURITY_V2 : COINBASE_MATURITY;

        bool fTestNet = (Params().NetworkIDString() == CBaseChainParams::TESTNET);
        if(fTestNet)
            nRequiredDepth = COINBASE_MATURITY_TESTNET;

        if (nRequiredDepth > nDepth)
            return state.DoS(100, error("%s: Tried to stake at depth %d", __func__, nDepth + 1), REJECT_INVALID, "invalid-stake-depth");

        kernelPubKey = coin.out.scriptPubKey;
        amount = coin.out.nValue;
        nBlockFromTime = pindex->GetBlockTime();
    };

    const CScript &scriptSig = txin.scriptSig;
    const CScriptWitness *witness = &txin.scriptWitness;
    ScriptError serror = SCRIPT_ERR_OK;
    // Redundant: all inputs are checked later during CheckInputs
    if (!VerifyScript(scriptSig, kernelPubKey, witness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&tx, 0, amount), &serror))
        return state.DoS(100, error("%s: verify-script-failed, txn %s, reason %s", __func__, tx.GetHash().ToString(), ScriptErrorString(serror)),
            REJECT_INVALID, "verify-script-failed");



    if (!CheckStakeKernelHash(pindexPrev, nBits, nBlockFromTime,
        amount, txin.prevout, nTime, hashProofOfStake, targetProofOfStake, LogAcceptCategory(BCLog::POS)))
        return state.DoS(1, // may occur during initial download or if behind on block chain sync
            error("%s: INFO: check kernel failed on coinstake %s, hashProof=%s", __func__, tx.GetHash().ToString(), hashProofOfStake.ToString()),
            REJECT_INVALID, "check-kernel-failed");

    // Ensure the input scripts all match and that the total output value to the input script is not less than the total input value.
    // Leaving a window for compromised staking nodes to reassign the blockreward to an attacker's address.
    // If coin owners detect this, they can move their coin to a new address.

    //Check if delegate service is charging a fee and is just
    if (HasIsCoinstakeOp(kernelPubKey))
    {
        if(pindexPrev->nHeight + 1 < Params().GetConsensus().nStartGhostFeeDistribution)
            return state.DoS(100, error("%s: LPoS contract cannot be staked now.", __func__), REJECT_INVALID, "nStartGhostFeeDistribution-start-too-soon");

        // Sum value from any extra inputs and check script is the same
        for (size_t k = 1; k < tx.vin.size(); ++k)
        {
            const CTxIn &txin = tx.vin[k];
            Coin coin;
            if (!pcoinsTip->GetCoin(txin.prevout, coin) || coin.IsSpent())
            {
                if (!GetTransaction(txin.prevout.hash, txPrev, Params().GetConsensus(), hashBlock, true)
                    || txin.prevout.n >= txPrev->vout.size())
                    return state.DoS(1, error("%s: prevout-not-in-chain %d", __func__, k), REJECT_INVALID, "prevout-not-in-chain");

                const CTxOut outPrev = txPrev->vout[txin.prevout.n];

                if (kernelPubKey != outPrev.scriptPubKey)
                    return state.DoS(100, error("%s: mixed-prevout-scripts %d", __func__, k), REJECT_INVALID, "mixed-prevout-scripts");
                amount += outPrev.nValue;

                LogPrint(BCLog::POS, "%s: Input %d of coinstake %s is spent.", k, tx.GetHash().ToString());
            } else
            {
                if (kernelPubKey != coin.out.scriptPubKey)
                    return state.DoS(100, error("%s: mixed-prevout-scripts %d", __func__, k), REJECT_INVALID, "mixed-prevout-scripts");
                amount += coin.out.nValue;
            }
        }

        // Get block reward
        CAmount nReward = Params().GetProofOfStakeReward(pindexPrev, 0);
        if (nReward < 0)
            return false;

        // Check if contract allows fee payouts
        int64_t feeOut = 0;
        CAmount feeAmount = 0;
        if(GetCoinstakeScriptFee(kernelPubKey, feeOut)){
            double feePercent = (double)feeOut;
            if(feeOut > 10000 || feeOut < 0){
                return state.DoS(100, error("%s: GetCoinstakeScriptFee-failed, txn %s", __func__, tx.GetHash().ToString()),
                    REJECT_INVALID, "GetCoinstakeScriptFee-failed");
            }
            feePercent /= 100;
            amount += nReward * (double)((100.0 - feePercent)/100.0);
            feeAmount = nReward * ((feePercent)/100);
        }
        else
            amount += nReward;

        CScript scriptOut;
        bool hasScriptFeeAddress = false;
        bool foundFeeAddress = true;
        if(GetCoinstakeScriptFeeRewardAddress(kernelPubKey, scriptOut)){
            hasScriptFeeAddress = true;
            foundFeeAddress = false;
        }

        CAmount nVerify = 0;
        for (const auto &txout : tx.vout)
        {
            const CScript pOutPubKey = txout.scriptPubKey;

            if (pOutPubKey == kernelPubKey)
                nVerify += txout.nValue;

            //Check for delegate fee address payout
            if(hasScriptFeeAddress){
                if(scriptOut == pOutPubKey && feeAmount == txout.nValue)
                    foundFeeAddress = true;
            }
        }

        if (nVerify < amount)
            return state.DoS(100, error("%s: verify-amount-script-failed, txn %s", __func__, tx.GetHash().ToString()),
                REJECT_INVALID, "verify-amount-script-failed");

        if (!foundFeeAddress)
            return state.DoS(100, error("%s: foundFeeAddress-failed, txn %s", __func__, tx.GetHash().ToString()),
                REJECT_INVALID, "foundFeeAddress-failed");
    }

    return true;
}


// Check whether the coinstake timestamp meets protocol
bool CheckCoinStakeTimestamp(int nHeight, int64_t nTimeBlock)
{
    return (nTimeBlock & Params().GetStakeTimestampMask(nHeight)) == 0;
}

bool CheckKernel(const CBlockIndex *pindexPrev, unsigned int nBits, int64_t nTime, const COutPoint &prevout, int64_t *pBlockTime)
{
    uint256 hashProofOfStake, targetProofOfStake;

    Coin coin;
    if (!pcoinsTip->GetCoin(prevout, coin))
        return error("%s: prevout not found", __func__);
    if (coin.IsSpent())
        return error("%s: prevout is spent", __func__);

    CBlockIndex *pindex = chainActive[coin.nHeight];
    if (!pindex)
        return false;

    int coinbaseMaturity = chainActive.Height() >= Params().GetConsensus().nCoinMaturityReductionHeight ?
                COINBASE_MATURITY_V2 : COINBASE_MATURITY;

    bool fTestNet = (Params().NetworkIDString() == CBaseChainParams::TESTNET);
    if(fTestNet)
        coinbaseMaturity = COINBASE_MATURITY_TESTNET;

    int nRequiredDepth = (int)(coinbaseMaturity-1);

    int nDepth = pindexPrev->nHeight - coin.nHeight;

    if (nRequiredDepth > nDepth)
        return false;

    if (pBlockTime)
        *pBlockTime = pindex->GetBlockTime();

    CAmount amount = coin.out.nValue;
    return CheckStakeKernelHash(pindexPrev, nBits, *pBlockTime,
        amount, prevout, nTime, hashProofOfStake, targetProofOfStake);
}

